## Flowcharts

# What are the difficulties involved in trying to keep things simple at the communications level whilst maintaining complexity at the algorithmic procedural level? 

The term “lost in translation” is true for maintaining complexity while translating to layman’s terms. It’s hard to translate computable processes as they are explained to great detail in programming language. When translating to layman’s terms you have a lot of decisions to make. Who is going to see the flowchart and how detailed would it have to be in order to be understandable for the reader. When we made our flowcharts we focused on keeping it simple for a couple of reasons. Details are subjects to change, and therefore we wouldn’t go into very specific algorithmic details as the project isn’t coded yet, and we would have to code the project and test our ideas in order to be sure it would be able to be executed properly. Also unexpected consequences can occur when programming, which could result in needed change in the algorithmic processes which could alter the structure of the flowchart.

The flowchart format is also limited in how you can present algorithmic processes, depending on how “detailed” you want to go, and that also largely depends on the expected end user of the flowchart. It's easier, for example, to make a retrospective flowchart of an algorithm, since you already have a perfect understanding of what you’ve accomplished.

# What are the technical challenges facing the two ideas and how are you going to address these?

As we’ve kept the flowcharts somewhat simple or at least haven’t gone into much technical detail with two seemingly large ideas, we’re likely to face a number of different technical challenges. We’ve already had some discussions about which syntaxes we could use in order to actualize our vision. Not only do we have to consider possible syntaxes, but this would furthermore influence how and which possible assets we would have to make. While we were brainstorming ideas, we made a lot of considerations regarding a variety of topics that we deemed as pertaining to the final project. These topics included interactivity, themes to address, and visual aesthetics. We ended up settling on two ideas that are largely experience-based. We wanted to incorporate interactivity from the user, in order to enhance immersion, as well as to exacerbate the user’s reflection regarding key topics that we wanted to address. Obviously our large focus on experience over interactivity has led to very linear flowcharts, where the user is largely a spectator. In our wheel of time flowchart, we’ve tried to include interactivity in the form of agency to “steer” the wheel, whilst still limiting the choice. You might consider it pseudo-interactivity, since there’s a predetermined outcome. It also further illustrates the utter helplessness that we want to articulate.  


# In which ways are the individual and the group flowcharts you produced useful?

The flowcharts that we’ve created are obviously of differing natures. Whilst the individual flowchart is largely retrospective, the group ones are preemptive / forward thinking. This means they serve distinctly different purposes. The individual flowchart provides a better understanding of your own code, and would prove very useful if one were to reevaluate or further develop your program. It also helps one see the bigger picture, and we feel that you’d be more accurately able to calculate how changing certain steps in the flowchart would affect the connecting steps. The group flowcharts helped us further conceptualize and articulate the initial concepts that we ideated through brainstorms. It helped structure our thoughts, and helped us further develop our ideas. 

In a group environment it is important that you are on the same page, when producing a project. It can be hard to conceptualize in a group, because everyone may have different styles of conceptualization, some might be visual, while others benefit more from talking through a project. Flowchart is a great way to combine thought and create consensus together in a group. Also when coding a flowchart can be seen as a plan of work, where you start from the top and create everything in the order of which they are connected in the chart.
